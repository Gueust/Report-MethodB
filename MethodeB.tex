\documentclass[10pt,a4paper]{article}
% Libraries
\usepackage[utf8]{inputenc} % [utf8] for linux, latin1 for windows
\usepackage[french]{babel} %\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx} 
\usepackage{longtable}

\usepackage{listings}
\usepackage{algorithmic}
\usepackage{float}

\usepackage[center]{caption}
\usepackage{subcaption}

%\usepackage{calc}
\usepackage{amsthm}
%\usepackage[usenames,dvipsnames]{xcolor}
%\usepackage{tikz}
%\usepackage[all]{xy}

\usepackage[hidelinks]{hyperref}
% To add a word in the links maded by hyperref
% but cleveref goes "laster" than hyperref
\usepackage[nameinlink,noabbrev, french]{cleveref}

% Must be after hyperref
\usepackage{algorithm}

% Pour ordonner les citations etc
\usepackage{cite}

\newtheorem{prop}{Proposition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{requirement}{Requirement}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem*{remarks}{Remarks}
\newtheorem{hypothesis}{Hypothesis}[section]
\newtheorem{example}{Example}

\newtheorem{axiom}{Axiome}
\renewcommand{\theaxiom}{\Roman{axiom}} %\renewcommand{\theaxiom}{\thechapter.\thesection.\arabic{axiom}}

\setcounter{secnumdepth}{3}

\author{Jean-Baptiste Lespiau et Charles Thin}
\title{La méthode B : une méthode formelle de développement logiciel}
\date\today


\newcommand{\Bequal}{\mathrel{\widehat{=}}}


%\renewcommand{\thechapter}{\Roman{chapter})}
%\renewcommand{\thesection}{\Roman{section}} %Alph
%\renewcommand{\thesubsection}{\arabic{subsection})}
%\renewcommand{\thesubsubsection}{\alph{subsubsection})}
%\renewcommand{\theparagraph}{\engrec{paragraph})}

\begin{document}
\maketitle
\tableofcontents
\newpage

\begin{abstract}
La méthode B, inventé par Jean-Raymond Abrial, est une méthode pour spécifier, concevoir et générer du code de systèmes logiciels tout en satisfaisant des contraintes de preuves de propriétés.
Elle est basée sur la théorie des ensembles de Zermelo-Fraenkel avec l'axiome du choix, le concept de substitutions généralisées et une certaine approche de la complexité (par la définition de machine abstraite, raffinement et d'implémentation).

%The concept of refinement is the key notion for developing B models
%of (software) systems in an incremental way. B models are accompanied by mathematical proofs that %justify
%them.
\end{abstract}

\iffalse
0) Courte intro: on va parler de quoi ?
Schema : Meteor: page 374
L'Atelier B inventé en 92 par Abrial, développé par ??.
Utilisé dans tels projets (Météor etc)
Une phrase qui décrit l'idée générale:
\item une théorie mathématique basée sur les ensembles et les relations
\item une méthode pour spécifier, concevoir et implémenter des logiciels
\item un langage
\item un ensemble d'outils autour de l'Atelier B
1)J-B Théorie des ensembles + théorie des relations (en annexe dans le rapport ?)
Exemples
3)[Charles] Explication des machines abstraites et de tous leurs champs
Définie dans Dossier-Technique page 9
Exemple de la bibliothèque: Cours B Part I 2007
4bis) Preuves
5)[Charles] Raffinement d'une machine abstraite (Dossier Technique page 10)
Rajouter un exemple (commence page 193 de Spécification avec B)
5bis) Obligation de preuves des raffinements
6) Preuves et obligations de preuves
7)[J-B] Implémentation d'un raffinement (définir ce qu'il doit contenir ou non).

A la fin:
Les tableaux pour donner les équivalences entre symboles mathématiques et grammaire.
\fi

\section{Introduction}

La méthode B c'est :
\begin{itemize}
\item une théorie mathématique basée sur la théorie des ensembles et des relations~;
\item une méthode pour spécifier, concevoir et implémenter des logiciels~;
\item un langage~;
\item un ensemble d'outils autour de l'Atelier B (ClearSy).
\end{itemize}
~\newline

En particulier, l'Atelier B est constitué de :
\begin{itemize}
\item un analyseur~;
\item un générateur d'obligation de preuve~;
\item un démonstrateur automatique~;
\item un démonstrateur interactif~;
\item un générateur de code C et Ada~;
\item un gestionnaire de projet.
\end{itemize}

Le formalisme de modélisation s'appuie sur plusieurs concepts : la théorie des ensembles, la logique des prédicats du premier ordre et le langage de substitutions généralisées.

Pour concevoir ce document, nous nous sommes basés sur \cite{behm1999meteor, habrias2006specifications, theBBook, dossierTechnique}

\subsection{Intérêt de la méthode B}
\emph{Dans tous les secteurs industriels ont été développées les notions très voisines de SIL (Safety Integrity Level) dans le domaine du transport ferroviaire et de l’industrie, d’ASIL (Automotive Safety Integrity Level ) dans le domaine automobile ou de DAL (Development Assurance Level) dans le domaine aéronautique. Un SIL est lié au niveau de confiance que l'on peut avoir dans un système. Ce niveau de confiance est associé au niveau de qualité du processus de conception/réalisation pour éviter les erreurs systématiques (principalement pour le logiciel ou des circuits intégrés complexes) et est associé à un niveau de probabilité par heure (et par ensemble) d'obtenir une défaillance contraire à la sécurité pour les erreurs aléatoires (principalement pour le matériel).}\cite{dossierTechnique}

\emph{Un processus de conception/réalisation est caractérisé par une organisation, des méthodes, des outils et des techniques spécifiques pour répondre au niveau de confiance exigé. Plus un logiciel est critique, plus on doit disposer d'une organisation robuste et des méthodes et outils qui permettent d'éviter les erreurs ou de les détecter si elles apparaissent malgré tout. Par exemple, dans le secteur ferroviaire, la norme EN50128 précise que pour un logiciel SIL3 et SIL4, les méthodes formelles sont hautement recommandées, et cela a tendance à se généraliser à l'ensemble du monde industriel.}\cite{dossierTechnique}

\section{Théorie sous-jacente de la méthode B}

\subsection{Axiomatique}
La théorie sous-jacente utilisée provient de la théorie des ensembles de Zermelo-Fraenkel avec axiome du choix (ZFC) dont les axiomes sont présentés en \cref{ZFC}.


Cependant, la théorie des ensembles utilisée dans B est une théorie simplifiée dans le sens où certains axiomes ne sont pas utilisés :
\begin{itemize}
\item Les deux axiomes de  Fraenkel~;
\item L'axiome de la réunion.
\end{itemize}~\newline
De plus, l'axiome de la paire est modifié pour construire une paire ordonnée et non un ensemble.\newline

Cela donne ainsi l'axiomatique:
\begin{description}
\item[Définition de la paire] $(E, F) \in s \times t \Leftrightarrow E \in s \wedge F \in t$
\item[Ensemble des parties] $s \in \mathbb{P}(t) \Leftrightarrow \forall x (x \in s \Rightarrow x \in t)$
\item[Ensemble en compréhension] $E \in \{ x | x \in s \wedge P \} \Leftrightarrow (E \in s \wedge [x:= E] P)$
\item[Égalité d'ensembles] $\forall x (x \in s \Leftrightarrow x \in t) \Rightarrow s = t$
\item[Axiome du choix] $\exists x  (x \in s) \Rightarrow choice(s) \in s$
\item[Axiome de l'infini] Existence d'un ensemble infini nommé BIG
\end{description}

\subsection{Type-checking}

L'idée est que lors de la preuve d'un prédicat ayant des variables liées à des quantificateurs, les variables liées sont supposées appartenir à un ensemble.
Sans en détailler ici toutes les implications, il est toutefois important de remarquer que l'ajout de ces contraintes de type-checking rend l'ensemble vide typé du type de l'ensemble dont il est le résultat (i.e. $\varnothing = A - A$), et il n'y a donc pas unicité de l'ensemble vide. 

\section{Machines abstraites}

\subsection{Description informelle}

La méthode B est fondée sur la notion de \emph{modèle}. Un\emph{modèle}, on le sait, doit pouvoir décrire les \emph{opérations} d'un système, ses données entrantes et sortantes et des valeurs (son \emph{état}) et des propriétés sur ces données et valeurs (des \emph{contraintes} ou \emph{invariants}).

Un utilisateur d'un système qui en connaît un modèle peut fournir des données et valeurs en entrée (i.e. fournir un état du système dans la modélisation actuelle) et observer l'état sortant. Tous ces  éléments (propriétés, données, opérations, état) peuvent être aussi abstraits et généraux que voulu.

L'utilisateur ne connaît rien du fonctionnement interne du système au delà de la précision de son modèle. Ainsi la suite des états internes par lesquels passe la machine lors d'une opération n'est pas accessible à l'utilisateur ayant déclenché l'opération.
\\

En méthode B, ces notions se traduisent dans une \emph{machine abstraite} : c'est exactement l'appellation en méthode B d'un modèle. Une machine abstraite propose et réalise des opérations (c'est une machine) directement implémentables en code logiciel ou non (elle est abstraite).

Notons, d'un point de vue industriel, qu'une machine abstraite représente un ensemble de besoins, d'exigences ou de spécifications de niveau donné. Nous verrons par la suite comment, de même que l'on précise et concrétise des besoins en exigences puis en spécifications de plus en plus précises et de plus en plus proche de l'implémentation, de même l'on passe de machines abstraites en machines moins abstraites.

\subsection{Description formelle}

Une machine abstraite c'est :
\\
\begin{itemize}
\item un \textbf{nom}, pour l'appel depuis l'extérieur~;
\\
\item des \textbf{paramètres}, dimensionnant la machine~;
\item des \textbf{contraintes}, sur les paramètres~;
\\
\item un \textbf{état}, composé des valeurs d'un ensemble de variables~;
\item des \textbf{types de données}, potentiellement abstraits, dans lesquels trouver les variables d'état~;
\item des \textbf{invariants}, propriétés sur l'état décrites en logique 1er ordre/ZFC~;
\item une \textbf{initialisation}, pour tout ce petit monde~;
\\
\item des \textbf{constantes}, valeurs utiles aux opérations, mais non modifiées par elles, et indépendantes de la machine~;
\item des \textbf{propriétés}, expressions logiques sur les constantes~;
\\
\item et enfin des \textbf{opérations}, qui modifient l'état de départ en l'état d'arrivée en conservant les invariants.
\end{itemize}
\ \\
Ce qui donne les mots clés de base en langage B, appelés \emph{clauses} :
\begin{itemize}
\item \textbf{MACHINE} sous lequel on nomme la machine~;
\item \textbf{CONSTRAINTS} sous lequel on contraint les paramètres~;
\item \textbf{VARIABLES} sous lequel on liste les variables constitutant l'état~;
\item \textbf{INITIALIZATION}, sous lequel on initialise les variables d'état~;
\item \textbf{INVARIANTS} sous lequel on énonce les invariants sur l'état~;
\item \textbf{CONSTANTS}, sous lequel on liste les constantes de fonctionnement~;
\item \textbf{PROPERTIES}, sous lequel on liste les propriétés logiques les constantes~;
\item \textbf{SETS}, sous lequel on liste les types de données utilisés pour cette machine~;
\end{itemize}
\ \\
Les paramètres sont quant à eux listés entre parenthèse après le nom de la machine. Il existe d'autres clauses, moins importantes pour la définition formelle, qui seront vues lorsque nécessaires, et sont en tous cas dans l'annexe.
\iffalse
La méthode B introduit un langage rigoureux pour représenter les programmes et leurs propriétés en utilisant le concept de substitution généralisée. Elle utilise la notion simple de machine abstraite qui est assez voisine de la notion d’objet, mais qui, en plus, intègre la notion d'invariant assurant la préservation de propriétés
des variables d’état de la machine, quelles que soient les opérations appliquées.

% Forcer des espaces du plus petit au plus grand
% \, \; \: \quad \qquad
\textbf{MACHINE}

\qquad $registeredP \ \subseteq \ Passenger \wedge registeredB \subseteq Luggage \wedge$

\qquad $registeredP \subseteq Passenger \wedge registeredB \subseteq Luggage \wedge$

\qquad $f \Bequal f$

\textbf{SETS}

\textbf{CONSTANTS}
\fi

\subsection Un exemple.

Cet exemple est tiré de TODO \iffalse(manque l'élément bibliographique)\fi.


\subsubsection Spécification d'un modèle en langage courant

Nous allons modéliser en B une bibliohèque.

Celle-ci gère des livres, des exemplaires de livres, et des abonnés : ce sont les types de données (en plus des types communs, dont les entiers qui nous seront utiles).

Les règles de la bilbiothèque sont les suivantes : un exemplaire est emprunté par au plus un abonné, et un abonné ne peut emprunter plus d'une certaine limite d'exemplaire. Ce sont les invariants de notre bibliothèque.

On peut dans cette bilbiothèque créer des livres ou des exemplaires de livres, et en prêter à des abonnés qui les empruntent. Ce sont nos opérations.


\subsection{Preuve d'invariants}

%Les propriétés invariantes sont vérifiées par la dynamique
%les raffinements préservent la correction totale

Pour prouver une opération dans une machine, il faut que son initialisation établisse l’invariant et que son exécution le conserve. Il faut donc vérifier que l’initialisation et l’opération elle-même respectent la propriété invariante de l’opération. Les invariants sont notés dans la clause INVARIANT de la machine abstraite. 

\section{Raffinement}

\subsection{Raffinement d'une machine abstraite}
\emph{De manière générale, le raffinement est une technique permettant la transformation d’un modèle abstrait de logiciel (sa spécification) en un autre modèle plus concret (son raffinement). Ce modèle peut contenir à la fois plus de détails par rapport à la spécification et être plus proche de la mise en œuvre (implantation). La technique de raffinement est aussi fondée sur la notion de substitution généralisée.}\cite{dossierTechnique}

\iffalse
Un raffinement peut utiliser une substitution T si T peut remplacer S sans que « l’utilisateur » de la machine ne s’en aperçoive. Cela signifie que tout ce qui est attendu de S sera rempli par T. On dit
alors que T est le raffinement de S ou que S est une abstraction de T.
\fi

Soit R un prédicat de la machine $M$ et $S$ une substitution de $M$ établissant le prédicat $R$: [S]R.
Une substitution \textbf{$T$ est un raffinement de S} s'il établit aussi R (i.e [T]R .

\emph{Le raffinement est conduit selon trois voies : la suppression des éléments non exécutables du pseudo-code (pré-condition et choix), l’introduction des structures classiques de contrôle de la programmation (séquence et boucle) et la transformation des structures de données mathématiques (ensembles, relations, fonctions,séquences et arbres) en d’autres structures qui permettent d’être programmable (variables simples, booléens, tableaux ou files).}\cite{dossierTechnique}

L’action élémentaire est formalisée au moyen d’une généralisation de la notion de substitution, dite \og substitution généralisée \fg. Parmi ces substitutions généralisées,
il y a des choix non déterministes laissant la place à des décisions plus tardives qui seront prises dans la phase de raffinement.

\section{Implémentation de modèles}

Le langage $B_0$ est un sous langage de la méthode B qui est directement traduisible en un programme (en ADA, C, C++, etc.).
L'implémentation est un raffinement d'une machine abstraite appartenant à $B_0$ et pouvant donc être utilisé pour la génération de code.

Voici une liste des principales caractéristiques d'une implémentation :
\begin{itemize}
\item Une machine IMPLEMENTATION n’a pas d’état qui lui est propre. Elle n’a pas de clause VARIABLES.
\item Elle doit importer (IMPORTS d’autres machines dont elle utilise les opérations pour implanter les opérations de la machine quelle implémente (qui est une MACHINE ou un REFINEMENT). 
\item Elle ne voit (SEES) que les opérations (leur signature)des machines importées. Elle ne voit pas leur variables d’état. Il y a donc un masquage total des “données”. 
\item Il n’y a plus ni indéterminisme ni substitution parallèle.
\item Les opérations n’ont plus de précondition. Mais le code est fourni sous l’hyppothèse que l’opération ne sera appelée que “sous sa précondition” (dit autrement, “que si sa précondition est respectée”). Et cela est dit dans la machine abstraite que l’on implante.
\end{itemize}

Les seules substitutions autorisées sont :
\begin{itemize}
\item :=
\item ; (la composition séquentielle)
\item IF ...THEN...ELSE...END et variantes
\item CASE
\item WHILE ...DO ...INVARIANT...VARIANT...END (la boucle avec l’invariant de boucle et le variant de boucle)
\item VAR ...IN ...END
\item Les opérations des machines importées
\item les opérations d’interrogation des machines vues
\item Les machines importées sont initialisées selon leur propre clause INITIALISATION, à moins que la machine IMPLEMENTATION ait une clause INITIALISATION.
\end{itemize}
\subsection{L'importation de machine par IMPORTS}

Elle a obligatoirement aussi une clause REFINES qui indique quelle machine (MACHINE
ou REFINEMENT) est implantée. \emph{Le lien IMPORTS entre une impantation MI et une instance de machine importée MA permet de créer l’instance de MA et ainsi de disposer de ses opérations.\cite{habrias2006specifications}}
Il n'est autorisé que dans une machine IMPLEMENTATION.

On peut en particulier importer des machines de bases ou des bibliothèques fournies avec l’Atelier B et qui fournissent des fonctionnalités. Il s'agit par exemple de BASIC\_IO pour les entrées/sorties usuelles et de L\_ARITHMETIQUE qui offre des opérations arithmétiques (i.e. exponentielle, racine carrée etc).

\section{B événementiel et programme}

\emph{Une machine en B  événementiel, on dit un système, n’a pas des opérations qui seront appelées par d’autres opérations, mais des  événements. Un  événement est spécifié comme une opération gardée. Un événement  est une transition qu’on peut observer.\newline
\indent Un  événement est déclenché lorsque sa garde est vérifiée. Si plusieurs événements sont déclenchables (i.e. leur garde est vérifiée), le déclenchement est indéterminisme. \newline
\indent Quand on raffine, alors qu’en B classique on affaiblit les préconditions, en B événementiel, on renforce les gardes. 
}habrias2006specifications

Preuve à réalisée en B événementiel:
\begin{itemize}
\item $Init \Rightarrow I(x)$
\item $ I(x) \wedge BA(e)(x, x') \Rightarrow I(x')$
\item $ I(x) \Rightarrow \left( grd(e_1) \vee \ldots grd(e_n) \right)$
\end{itemize}


\appendix

\section{Théorie ZFC}
\label{ZFC}
La théorie des ensembles de Zermelo est publiée en 1908 et instaure une axiomatique pour formuler une théorie moderne des ensembles qui n'est pas confrontée aux paradoxes de la théorie de Cantor (par exemple, le paradoxe lié à l'existence d'un ensemble qui contiendrait tous les ensembles).

En 1922, Fraenkel et Skolem ajoutent des axiomes et le système en résultant est connu sous le nom de théorie de Zermelo-Fraenkel, abrégé en ZF.

On utilise la logique du premier ordre.
TODO: développer un peu cette logique.

\subsection{Théorie de Zermelo (Z)}

\begin{axiom}[Axiome d'extensionnalité] Cet axiome définit l'égalité entre ensemble comme l'égalité de leurs éléments.
\begin{align}
\forall A\ \forall B \
\left[ 
\forall x \left( x \in A \Leftrightarrow x \in B  \right) \Rightarrow A = B
\right] 
\end{align}
\end{axiom}

\begin{axiom}[Axiome de la paire] Cet axiome définit, à partir deux ensemble A et B, un nouvel ensemble paire contenant A et B exactement.
\begin{align}
\forall A \ \forall B \ \exists C \forall x \left[ x \in C \Leftrightarrow \left( x = A \vee x = B \right) \right]
\end{align}
\end{axiom}

\begin{axiom}[Axiome de la réunion] Cet axiome définit, à partir d'un ensemble A, un nouvel ensemble $\bigcup A$ contenant les éléments des éléments de A. Avec l'axiome de la paire on peut définir l'union avec $A \cup B = \bigcup \left\{A, B\right\}$.
\begin{align}
\forall A\ \exists B\ \forall C\ \left( C\in B \Leftrightarrow \exists D\ \left( D\in A \wedge C\in D \right) \right)
\end{align}
\end{axiom}


\begin{axiom}[Schéma d'axiomes de compréhension] Aussi appelé, schéma d'axiomes de séparation, il permet de définir la construction d'ensembles en compréhension. Étant donné un ensemble $A$ et une propriété $\varphi$, il affirme l'existence de l'ensemble B des éléments de A vérifiant la propriété $\varphi$.

Ainsi, pour toute propriété $\varphi$ ne contenant pas d'autre variable libre que $x, a_1 \ldots a_p$ on définit l'axiome suivant :
\begin{align}
\forall a_1 \ldots a_n \ \forall A \ \exists B \ \forall x \ \left( x \in B \Leftrightarrow \left[ x \in A \wedge \varphi \left(x, a_1, \ldots, a_n \right) \right] \right) 
\end{align}
\end{axiom}

\begin{axiom}[Axiome de l'infini] Cet axiome définit qu'il existe un ensemble auquel appartient l'ensemble vide et qui est clos par application du successeur$ x \rightarrow x \cup \{x\}$. Il permet ainsi de construire un ensemble qui contient une représentation des entiers naturels. On note que l'ensemble vide existe comme conséquence de la logique du premier ordre du schéma d'axiomes de compréhension.
\begin{align}
\exists A \left( \emptyset \in A \land \forall x (x \in A \Rightarrow x \cup \{x\} \in A) \right) 
\end{align}
\end{axiom}

\begin{axiom}[Axiome de l'ensemble des parties] Cet axiome définit que pour tout ensemble $A$ il existe un ensemble auquel appartiennent exactement tous les sous-ensembles de $A$.
\begin{align}
\forall A \ \exists P \ \forall B \left[B \in P \Leftrightarrow \forall C \left( C \in B \Rightarrow C \in A \right) \right] 
\end{align}
\end{axiom}

On note ici que l'axiome de l'existence de l'ensemble vide n'est pas mentionné car il peut aussi être introduit à partir de la logique du premier ordre du schéma d'axiomes de compréhension.

Dès qu'il existe un ensemble, l'existence de l'ensemble vide peut être démontrée par compréhension, comme étant le sous-ensemble des éléments de celui-ci qui vérifient une propriété toujours fausse.
Or, en logique du premier ordre, les domaines d'interprétation des variables d'objets de base, ici des variables d'ensemble, sont non vides, ce qui permet donc de prouver l'existence de l'ensemble vide.

De plus, l'unicité de l'ensemble vidé découle de l'axiome d'extensionnalité.

\subsection{Théorie de Zermelo-Fraenkel (ZF)}

La théorie ZF ajoute deux axiomes à l'axiomatique déjà présentée.

\begin{axiom}[Axiome de fondation] Tout ensemble non vide x possède un élément y tel que x et y soit disjoint.
\begin{align}
\forall x [ \exists a ( a \in x) \Rightarrow \exists y ( y \in x \land \lnot \exists z (z \in y \land z \in x))]. 
\end{align}
\end{axiom}

\begin{axiom}[Schéma d'axiomes de remplacement] Ce schéma étend le schéma d'axiomes de compréhension de la théorie de Zermelo. Il définit que un ensemble A étant donné, son image par une relation fonctionnelle est un ensemble.

Ainsi, pour toute propriété $\phi$ ne contenant pas d'autre variable libre que $x, y, a_1 \ldots a_p$ on définit l'axiome suivant :
\begin{align}
\forall A \ \forall a_1 \forall \ a_2 \ldots \forall a_n \ 
\bigl[ \forall x ( x\in A \Rightarrow \exists! y\,\phi ) \Rightarrow \exists B \ \forall x \bigl(x\in A \Rightarrow \exists y (y\in B \land \phi) \bigr) \bigr]
\end{align}
\end{axiom}

\subsection{Théorie de Zermelo-Fraenkel avec axiome du choix (ZFC)}

\begin{axiom}[Axiome du choix] Étant donné un ensemble X d'ensembles non vides, il existe une fonction définie sur X, appelée fonction de choix, qui à chacun d'entre eux associe un de ses éléments.
\begin{align}
\forall X \left[ \emptyset \notin X \Rightarrow \exists f: X \rightarrow \bigcup X, \quad \forall A \in X \, ( f(A) \in A ) \right] \,. 
\end{align}
\end{axiom}

\section Compléments syntaxiques du langage B :

\subsection Autres clauses des machines abstraites :

\textbf{ASSERTIONS} : Propriété logique dérivée des invariants, contraintes et propriétés. Étant dérivées, i.e. induites par le reste, il n'est pas nécessaire de les démontrer - et même, elles n'impliquent a priori pas réciproquement le reste. En revanche, elles facilitent le travail du prouveur automatique.

\textbf{DEFINITIONS} : Alias facilitant la rédaction du reste de la machine.

TODO : $ABSTRACT\_CONSTANTS$, $CONCRETE\_VARIABLES$

% ===================================
% Bib
\bibliographystyle{plain}
\bibliography{biblio.bib}
% ===================================

\end{document}